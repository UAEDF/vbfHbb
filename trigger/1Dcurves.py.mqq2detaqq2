#!/usr/bin/env python

from string import Template
from glob import glob
import subprocess 
import threading
from time import sleep,strftime,gmtime,localtime
import Queue
import os,sys,shutil
from optparse import OptionParser,OptionGroup

colours = ["\033[0;31m","\033[0;32m","\033[0;33m","\033[0;34m","\033[0;35m","\033[0;36m","\033[m"]
exitFlag = 0
queueLock = None
workQueue = None
#-
selbase = "run194270;jetPt1"
selextra = {}
selextra["AV40"] = ["dEtaqq2","mqq3600","HT100","HTlt400"]
selextra["AV80"] = ["dEtaqq2","mqq3600","HT100","HTgt400"]
refsel = {}
refsel["AV40"] = "HTlt400"
refsel["AV80"] = "HTgt400"
weight=Template('''-w "$LUM,PU;XSEC;LUMI;MAP#mqq[2]#dEtaqq[2],,,rootfiles/vbfHbb_2013_2DMaps_mqq2-dEtaqq2_interpolated.root;2DMaps/JetMon-QCD/2DMap_JetMon-QCD-Rat_sHT100-$REFSEL-jetPt1-run194270-tVBF-r$REF-dVBFOR_mqq2-dEtaqq2;1"''')
samples="JetMon,QCD"
drawopts=['--drawstack --shade --overlay']#["--redrawstack --shade","--drawstack --shade --overlay"]
#-
baseline=Template('''./mkTurnonCurves.py -d -D "../common/vbfHbb_defaultOpts_2013.json" -G "/data/UAData/autumn2013" -t "$T" --datatrigger "$DT" --binning "mqq2;50;500;3000,mbb2;30;0;300,ht;75;0;1500,dEtaqq2;60;2;8,mbbReg2;30;0;300,jetPt0;40;0;400,jetPt1;30;0;300,mvaVBF;20;-1;1" -s "%s"'''%(samples))
selection=Template('''-p "$SEL"''')
variables=Template('''-v "$VARS"''')
reference=Template('''-r "$REF"''')
#-
outputbase="vbfHbb_2013_2DMapCorrected_mqq2-detaqq2_triggercurves"
outputtemp=Template('''%s$SUFTAG'''%outputbase)
output=Template('''-o "rootfiles/%s$SUFTAG$SUFFIX.root"'''%outputbase)
redirect=Template('''>> log/log$REDI$SUFTAG.log''')

def tasks(opts,workQueue):
	global selbase
	global selextra
	global refsel

	trg = "VBF"
	dtrg = "VBFOR"
	lumi = "18000."

	# all for 2 references
	vars = "ht,dEtaqq2,mvaVBF,mqq2,mbbReg2,jetPt0,jetPt1"
	for ref in ['AV80']: #['AV40','AV80']:
		sel = ';'.join([selbase]+selextra[ref])
		cmd = makeCmd(sel,trg,dtrg,vars,ref,refsel[ref],lumi) 
		workQueue.put((1,cmd))

####################################################################################################
####################################################################################################
def myparser():
	cyangrey = "\033[0;36;47m"
	cyan = "\033[0;36m"
	green = "\033[0;32m"
	plain = "\033[m"
	mp = OptionParser()
	mg0 = OptionGroup(mp,cyangrey+"Main options"+plain)
	mg0.add_option('--tag',help=cyan+'Suffix tag for filenames.'+plain,type='str',default='')
	mg0.add_option('-p','--print-only',help=cyan+'Only print commands to run.'+plain,action='store_true',default=False)
	mg0.add_option('-t','--threads',help=cyan+'Number of threads to use.'+plain,type='int',default=4)
	mg0.add_option('--delete',help=cyan+'Delete root files.'+plain,action='store_true',default=False)
	mg0.add_option('--no-colour',help=cyan+'B/W output.'+plain,action='store_true',default=False)
	mg0.add_option('--redo',help=cyan+'Rerun with existing file.',action='store_true',default=False)
	mg0.add_option('--first',help=cyan+'Only do redrawstack.',action='store_true',default=False)
	mp.add_option_group(mg0)
	return mp
	
def now():
	return strftime("%Y%m%d-%H%M%S",localtime())

####################################################################################################
####################################################################################################
def makeCmd(sel,trg,dtrg,vars,ref,refsel,lumi):
	cmd = ' '.join([ \
		baseline.safe_substitute(T=trg,DT=dtrg),\
		selection.safe_substitute(SEL=sel),\
		variables.safe_substitute(VARS=vars),\
		reference.safe_substitute(REF=ref),\
		weight.safe_substitute(LUM=lumi,REF=ref,REFSEL=refsel),\
		])
	return cmd

def execCmd(opts,id,name,cmd):
	out = output.safe_substitute(SUFFIX=str(id) if not opts.redo else "",SUFTAG=opts.tag)
	redi = redirect.safe_substitute(REDI=id,SUFTAG=opts.tag)
	fullcmd = ' '.join([cmd,out,redi])

	if opts.no_colour: print "\033[1;31;42m%s processing\033[m:\n" % (name), fullcmd, '\n'
	else: print "\033[1;31;42m%s processing\033[m:\n" % (name),colours[id],fullcmd,'\n',colours[-1]

	if not opts.print_only:
		p = subprocess.Popen(fullcmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
		lstdout, lstderr = p.communicate()
	else: lstdout, lstderr = "",""
	return lstdout,lstderr

class myThread(threading.Thread):
    def __init__(self, opts, threadID, name, q):
		threading.Thread.__init__(self)
		self.threadID = threadID
		self.name = name
		self.q = q
		self.stdout = None 
		self.stderr = None
		self.opts = opts
    def run(self):
		print "\033[1;31mStarting " + self.name + "\033[m\n"
		self.stdout,self.stderr = processData(self.opts,self.threadID,self.name,self.q)
		if not self.opts.print_only:
			print self.stdout
			print self.stderr
		print "\033[1;31mExiting " + self.name + "\033[m\n"

def processData(opts, threadID, threadName, q):
	global queueLock
	global workQueue
	global exitFlag
	stdout = ""
	stderr = ""
	while not exitFlag:
		queueLock.acquire()
		if not workQueue.empty():
			data = q.get()
			queueLock.release()
			for drawopt in drawopts: 
				if opts.redo and 're' in drawopt: continue
				if opts.first and not 're' in drawopt: continue
				lstdout,lstderr = execCmd(opts,threadID,threadName,' '.join([data[1],drawopt]))
				stdout += lstdout
				stderr += lstderr
		else:
			queueLock.release()
	return stdout,stderr	

####################################################################################################
# MAIN #############################################################################################
def main():
	mp = myparser()
	opts,args = mp.parse_args()

	global queueLock
	global workQueue
	global exitFlag
	outputfile=outputtemp.safe_substitute(SUFTAG=opts.tag)
	
	nthreads = opts.threads if not (opts.print_only or opts.redo) else 1
	
	if not opts.print_only:
		if not os.path.exists('log/'): os.makedirs('log/')
		for i in range(nthreads):
			open('log/log%i%s.log'%((i+1),opts.tag),'w').close()
	
	if not opts.print_only:
		if opts.delete:
			if os.path.exists("rootfiles/%s.root"%outputfile): 
				os.remove("rootfiles/%s.root"%outputfile)
			for i in range(nthreads): 
				if os.path.exists("rootfiles/%s%i.root"%(outputfile,i+1)): os.remove("rootfiles/%s%i.root"%(outputfile,i+1))
		elif opts.redo:
			if not os.path.exists("rootfiles/%s.root"%outputfile): sys.exit("rootfiles/%s.root doesn't exist. Stopping."%outputfile)
		else:
			if os.path.exists("rootfiles/%s.root"%outputfile): 
				os.rename("rootfiles/%s.root"%outputfile,"rootfiles/%s.root.%s"%(outputfile,now()))
			for i in range(nthreads): 
				if os.path.exists("rootfiles/%s%i.root"%(outputfile,i+1)): sys.exit("rootfiles/%s%i.root exists. Stopping."%(outputfile,i+1))

	
	threadList = []
	for i in range(nthreads): threadList += ["Thread-%i"%(i+1)]
	queueLock = threading.Lock()
	workQueue = Queue.PriorityQueue(100)
	threads = []
	threadID = 1
	
	# Create new threads
	for tName in threadList:
	    thread = myThread(opts, threadID, tName, workQueue)
	    thread.start()
	    threads.append(thread)
	    threadID += 1
	
	# Fill the queue
	queueLock.acquire()
	tasks(opts,workQueue)
	queueLock.release()

	# Wait for queue to empty
	while not workQueue.empty():
	    pass
	
	# Notify threads it's time to exit
	exitFlag = 1
	
	# Wait for all threads to complete
	for t in threads:
	    t.join()
	print "\033[1;31;43mExiting Main Thread\033[m"
	
	if not (opts.print_only or opts.redo):
		allroot = []
		for i in range(nthreads): allroot += ["rootfiles/%s%i.root"%(outputfile,(i+1))]
		os.system("hadd rootfiles/%s.root "%outputfile + " ".join(allroot))
		for i in range(nthreads): 
			os.system("cp -RT plots/%s%i/ plots/%s/"%(outputfile,(i+1),outputfile))
			shutil.rmtree("plots/%s%i"%(outputfile,(i+1)))
			os.remove("rootfiles/%s%i.root"%(outputfile,(i+1)))
	
if __name__=='__main__':
	main()
